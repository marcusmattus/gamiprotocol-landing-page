"use strict";var e=require("./privy-provider-Cc-fBpNe.js"),r=require("react"),t=require("./paths-B00ZrFQm.js"),s=require("./internal-context-B_aIJuQh.js"),a=require("./use-sign-with-user-signer-mIruAdfm.js"),n=require("./useActiveWallet-CGbGRerk.js"),o=require("./frame-8JZCzmCf.js"),i=require("@privy-io/public-api"),l=require("react/jsx-runtime"),u=require("@heroicons/react/24/outline/QuestionMarkCircleIcon"),c=require("@heroicons/react/24/outline/ShieldCheckIcon"),d=require("viem"),h=require("viem/utils"),y=require("@privy-io/js-sdk-core"),p=require("./getEmbeddedConnectedWallet-DTU4T9TJ.js"),w=require("viem/accounts");function g(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}require("mipd"),require("react-device-detect"),require("uuid"),require("jose"),require("eventemitter3"),require("@coinbase/wallet-sdk"),require("@privy-io/ethereum"),require("@marsidev/react-turnstile"),require("styled-components"),require("tinycolor2"),require("@heroicons/react/24/outline/DevicePhoneMobileIcon"),require("@heroicons/react/24/outline/FingerPrintIcon"),require("@heroicons/react/24/outline/PhoneIcon"),require("@heroicons/react/24/outline/ArrowLeftIcon"),require("@heroicons/react/24/outline/ArrowRightIcon"),require("@heroicons/react/24/outline/XMarkIcon"),require("@heroicons/react/24/outline/CalendarIcon"),require("@heroicons/react/24/outline/ExclamationTriangleIcon"),require("@heroicons/react/24/outline/ChevronDownIcon"),require("zustand"),require("@headlessui/react"),require("lucide-react"),require("@walletconnect/ethereum-provider"),require("fast-password-entropy"),require("secure-password-utilities"),require("secure-password-utilities/wordlists"),require("@heroicons/react/24/outline/UserCircleIcon"),require("@heroicons/react/20/solid/CheckIcon"),require("@heroicons/react/24/outline/EnvelopeIcon"),require("@heroicons/react/24/outline/WalletIcon"),require("@heroicons/react/24/outline/ExclamationCircleIcon"),require("@heroicons/react/24/outline/Square2StackIcon"),require("@heroicons/react/24/outline"),require("@tanstack/react-virtual"),require("@heroicons/react/24/outline/CheckIcon"),require("qrcode"),require("@heroicons/react/24/outline/LockClosedIcon"),require("@heroicons/react/24/outline/PencilSquareIcon"),require("@heroicons/react/24/outline/ArrowPathIcon"),require("@heroicons/react/24/outline/EyeIcon"),require("@heroicons/react/24/outline/EyeSlashIcon"),require("@heroicons/react/24/outline/KeyIcon"),require("@heroicons/react/24/solid/CheckCircleIcon"),require("@heroicons/react/24/outline/ArrowDownTrayIcon"),require("@heroicons/react/24/outline/ClipboardDocumentCheckIcon"),require("@heroicons/react/24/outline/DocumentDuplicateIcon"),require("@heroicons/react/24/solid/XCircleIcon"),require("@heroicons/react/24/outline/CheckCircleIcon"),require("@heroicons/react/24/outline/InformationCircleIcon"),require("@heroicons/react/24/outline/CreditCardIcon"),require("@heroicons/react/24/outline/QrCodeIcon"),require("@heroicons/react/24/solid/ArrowsRightLeftIcon"),require("@heroicons/react/24/outline/GlobeAltIcon"),require("ofetch"),require("@heroicons/react/24/outline/ClipboardDocumentIcon"),require("@heroicons/react/24/solid/CheckBadgeIcon"),require("@heroicons/react/24/solid/IdentificationIcon"),require("@heroicons/react/24/outline/ChevronRightIcon"),require("@heroicons/react/24/outline/MinusCircleIcon"),require("@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon"),require("@heroicons/react/24/outline/ClockIcon"),require("@heroicons/react/24/solid/ShieldCheckIcon"),require("js-cookie");var C=/*#__PURE__*/g(u),v=/*#__PURE__*/g(c);const A=()=>{let{setModalData:t}=e.usePrivyModal(),{openModal:n,privy:o,closePrivyModal:l}=s.usePrivyInternal(),{user:u}=a.usePrivyContext();return r.useMemo((()=>({verify:async({standalone:r=!0}={standalone:!0})=>new Promise(((s,a)=>u?0===u.mfaMethods.length?s():(t((t=>({...t,mfaVerify:{onSuccess:async()=>{r?await l({shouldCallAuthOnSuccess:!1,isSuccess:!0}):e.useCorePrivyStateStore.setState({inProgressMfaFlow:void 0}),s()},onFailure:async t=>{r?await l({shouldCallAuthOnSuccess:!1,isSuccess:!1}):e.useCorePrivyStateStore.setState({inProgressMfaFlow:void 0}),a(t)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await o.fetchPrivyRoute(i.MfaAuthTotpVerify,{body:{code:e}})},generateOptions:async()=>e.transformOptionsToCamelCase((await o.fetchPrivyRoute(i.MfaAuthPasskeyInit,{body:{}})).options),verifyPasskey:async r=>{let t=await import("@simplewebauthn/browser"),s=await t.startAuthentication(r);await o.fetchPrivyRoute(i.MfaAuthPasskeyVerify,{body:{authenticator_response:e.transformResponseToSnakeCase(s)}})}}}))),void(r?n(e.MfaAuthVerifyFlowScreen):e.useCorePrivyStateStore.setState({inProgressMfaFlow:"auth"}))):a(Error("Must be logged in to verify MFA"))))})),[o,t,n,l])},m={component:()=>{let{user:t,ready:s}=a.usePrivyContext(),{app:n,data:o,onUserCloseViaDialogOrKeybindRef:i}=e.usePrivyModal(),[u,c]=r.useState(null),[d,h]=r.useState(null),[y,p]=r.useState(null),[w,g]=r.useState(!1),[A,m]=r.useState(!1),[f,P]=r.useState(),E=async()=>{f?k(f):t?await S({user:t}):k(Error("Must be logged in to manage MFA")),setTimeout((()=>{c(null),h(null)}),500)};if(i.current=E,!o?.mfaEnroll)throw Error("Missing modal data for MFA enrollment screen.");let{onFailure:k,onSuccess:S,mfaMethods:x,verify:W,generateTotpSecret:T,enrollTotp:b,unenrollTotp:I,enrollPasskey:U}=o.mfaEnroll,M=t?.mfaMethods.includes("sms"),R=t?.mfaMethods.includes("totp"),F=t?.mfaMethods.includes("passkey"),q=!!t?.phone,O=t?.linkedAccounts.filter((e=>"passkey"===e.type)).map((e=>e.credentialId))??[];function N(){c(null),h(null),P(void 0)}async function _(e=O){try{P(void 0),m(!0);let r=await U(e);return await S({user:r})}catch(e){P(e)}finally{m(!1),g(!1)}}if(!s||!t||!n)/*#__PURE__*/return l.jsxs(l.Fragment,{children:[/*#__PURE__*/l.jsx(e.ModalHeader,{onClose:E},"header"),/*#__PURE__*/l.jsx(e.AppLogoContainer,{children:/*#__PURE__*/l.jsx(e.MfaShieldIcon,{})}),/*#__PURE__*/l.jsx(e.Container,{children:/*#__PURE__*/l.jsx(e.Loader,{})}),/*#__PURE__*/l.jsx(e.ModalFooter,{})]});if("sms"===u)return null;if("totp"===u)/*#__PURE__*/return l.jsxs(l.Fragment,{children:[/*#__PURE__*/l.jsx(e.ModalHeader,{backFn:N,onClose:E},"header"),/*#__PURE__*/l.jsx(e.IconWrapper,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/l.jsx(C.default,{})}),/*#__PURE__*/l.jsx(e.Title,{children:"Remove authenticator app verification?"}),/*#__PURE__*/l.jsxs(e.SubTitle,{children:["MFA adds an extra layer of security to your ",n?.name," account. Make sure you have other methods to secure your account."]}),/*#__PURE__*/l.jsx(e.BottomSection,{children:/*#__PURE__*/l.jsx(e.PrimaryButton,{$warn:!0,onClick:async function(){try{P(void 0),m(!0);let e=await I();return await S({user:e})}catch(e){P(e)}finally{m(!1),c(null)}},loading:A,children:"Remove"})}),/*#__PURE__*/l.jsx(e.ModalFooter,{})]});if("passkey"===u){let r=o.mfaEnroll.shouldUnlinkOnUnenrollMfa??!0;/*#__PURE__*/return l.jsxs(l.Fragment,{children:[/*#__PURE__*/l.jsx(e.ModalHeader,{backFn:N,onClose:E},"header"),/*#__PURE__*/l.jsx(e.IconWrapper,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/l.jsx(C.default,{})}),/*#__PURE__*/l.jsx(e.Title,{children:"Are you sure you want to remove this passkey?"}),/*#__PURE__*/l.jsx(e.SubTitle,{children:r?"Removing your passkey will remove as both a verification method and a login method.":"Removing your passkey will remove as a verification method."}),/*#__PURE__*/l.jsx(e.BottomSection,{children:/*#__PURE__*/l.jsx(e.PrimaryButton,{$warn:!0,onClick:async function(){try{P(void 0),m(!0);let e=await U([]);return await S({user:e})}catch(e){P(e)}finally{m(!1),c(null)}},loading:A,children:"Remove"})}),/*#__PURE__*/l.jsx(e.ModalFooter,{})]})}return 0!==x.length||M||R||F?"sms"===d?null:"totp"===d&&y?/*#__PURE__*/l.jsx(e.EnrollTotp,{onClose:E,onReset:N,submitEnrollmentWithTotp:e=>async function(e){try{P(void 0),m(!0);let r=await b(e);return await S({user:r})}catch(e){P(e)}finally{m(!1),c(null)}}(e.mfaCode),error:f,totpInfo:{...y,appName:n?.name||"Privy"}}):"passkey"===d?/*#__PURE__*/l.jsx(e.EnrollPasskey,{onReset:N,onClose:E,submitEnrollmentWithPasskey:_}):/*#__PURE__*/l.jsx(e.EnrollLandingScreen,{showIntro:!1,userMfaMethods:t.mfaMethods,appMfaMethods:n.mfa.methods,userHasAuthSms:q,onBackToIntro:()=>{},handleSelectMethod:async function(e){P(void 0);try{await W()}catch(e){return void P(e)}return"totp"===e?(h(e),p(null),void T().then((({totpSecret:e,totpAuthUrl:r})=>{p({authUrl:r,secret:e})})).catch((()=>{p(null),N()}))):"passkey"===e&&1===O.length?await _():void h(e)},isTotpLoading:"totp"===d&&!y,isPasskeyLoading:w,error:f,onClose:E,setRemovingMfaMethod:async function(e){P(void 0);try{await W()}catch(e){return void P(e)}c(e)}}):/*#__PURE__*/l.jsxs(l.Fragment,{children:[/*#__PURE__*/l.jsx(e.ModalHeader,{onClose:E},"header"),/*#__PURE__*/l.jsx(e.IconWrapper,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/l.jsx(v.default,{})}),/*#__PURE__*/l.jsx(e.Title,{children:"Add more security"}),/*#__PURE__*/l.jsxs(e.SubTitle,{children:[n?.name," does not have any verification methods enabled."]}),/*#__PURE__*/l.jsx(e.BottomSection,{children:/*#__PURE__*/l.jsx(e.PrimaryButton,{onClick:E,children:"Close"})}),/*#__PURE__*/l.jsx(e.ModalFooter,{})]})}};const f=()=>{let{ready:t,wallets:n}=e.useWallets(),{user:o}=a.usePrivyContext(),{rpcConfig:i,chains:l,appId:u}=s.usePrivyInternal();return{signAuthorization:r.useCallback((async(r,s)=>{let c;if(!o)throw Error("User must be authenticated before signing with a Privy wallet");if(!t)throw Error("Wallets are not ready");let y=s?.address??a.getPrivyEthereumWallet(o)?.address??d.zeroAddress,p=n.find((e=>d.getAddress(e.address)===d.getAddress(y)));if(!p)throw Error("Signing wallet not found.");let w=r.chainId??Number(p.chainId.split(":")[1]);if(0===w)c={chainId:0,address:r.contractAddress,nonce:r.nonce??0};else{let t=l.find((e=>e.id===w));if(!t)throw Error("Error, chain not configured in PrivyProvider config");let s=d.createWalletClient({account:y,chain:t,transport:d.http(e.getJsonRpcEndpointFromChain(t,i,u))});c=await s.prepareAuthorization({...r})}let g=await p.getEthereumProvider(),C=await g.request({method:"secp256k1_sign",params:[h.hashAuthorization(c)]});return{...c,...d.parseSignature(C)}}),[t,n,o,l])}},P=f;let E=async(e,r,s,a,n)=>{if(!e)throw a("linkAccount","onError",t.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:n}),new t.PrivyClientError("User must be authenticated before linking an account.");if(!r?.linkedAccounts.some((e=>e.type.includes(n))))throw new t.PrivyClientError(`OAuth account of type ${n} not linked to the account.`);await s(n)};exports.Captcha=e.Captcha,exports.ConnectorManager=e.ConnectorManager,exports.EthereumWalletConnector=e.EthereumWalletConnector,exports.LoginModal=e.LoginModal,exports.PrivyClient=e.PrivyClient,exports.PrivyProvider=e.PrivyProvider,exports.VERSION=e.VERSION,exports.WalletConnector=e.WalletConnector,exports.errorIndicatesMaxMfaRetries=e.errorIndicatesMaxMfaRetries,exports.errorIndicatesMfaTimeout=e.errorIndicatesMfaTimeout,exports.errorIndicatesMfaVerificationFailed=e.errorIndicatesMfaVerificationFailed,exports.getAccessToken=e.getCustomerAccessToken,exports.useCreateWallet=e.useCreateWallet,exports.useIdentityToken=e.useIdentityToken,exports.useImportWallet=e.useImportWallet,exports.useLogout=e.useLogout,exports.useMfa=e.useMfa,exports.useMfaEnrollment=e.useMfaEnrollment,exports.useMigrateWallets=e.useMigrateWallets,exports.usePrivy=e.usePrivy,exports.useRegisterMfaListener=e.useRegisterMfaListener,exports.useSolanaWallets=e.useSolanaWallets,exports.useSyncJwtBasedAuthState=e.useSyncJwtBasedAuthState,exports.useWallets=e.useWallets,exports.useActiveWallet=n.useActiveWallet,exports.useConnectWallet=n.useConnectWallet,exports.useFundWallet=n.useFundWallet,exports.useLogin=n.useLogin,Object.defineProperty(exports,"SUPPORTED_CHAINS",{enumerable:!0,get:function(){return y.DEFAULT_SUPPORTED_CHAINS}}),Object.defineProperty(exports,"addPrivyRpcToChain",{enumerable:!0,get:function(){return y.addPrivyRpcToChain}}),Object.defineProperty(exports,"addRpcUrlOverrideToChain",{enumerable:!0,get:function(){return y.addRpcUrlOverrideToChain}}),exports.getEmbeddedConnectedWallet=p.getEmbeddedConnectedWallet,exports.toViemAccount=async({wallet:e})=>{let r=await e.getEthereumProvider();return w.toAccount({address:e.address,sign:async({hash:t})=>{if("privy"!==e.walletClientType)throw new y.PrivyClientError({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await r.request({method:"secp256k1_sign",params:[t]})},signMessage:async({message:t})=>await r.request({method:"personal_sign",params:[t,e.address]}),signTypedData:async t=>await r.request({method:"eth_signTypedData_v4",params:[e.address,t]}),signTransaction:async e=>await r.request({method:"eth_signTransaction",params:[e]})})},exports.useAuthMfa=A,exports.useAuthMfaEnrollment=()=>{let t=e.useAppConfig(),{setModalData:a}=e.usePrivyModal(),{verify:n}=A(),{openModal:o,privy:l,closePrivyModal:u,refreshSessionAndUser:c,setUser:d}=s.usePrivyInternal();return r.useMemo((()=>({enroll:async()=>new Promise(((e,r)=>{a({mfaEnroll:{onSuccess:async r=>{await u({shouldCallAuthOnSuccess:!1,isSuccess:!0}),e(r)},onFailure:async e=>{await u({shouldCallAuthOnSuccess:!1,isSuccess:!1}),r(e)},verify:()=>n({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:t.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await l.fetchPrivyRoute(i.MfaAuthTotpInit,{body:{}}),enrollTotp:async e=>{await l.fetchPrivyRoute(i.MfaAuthTotpEnroll,{body:{code:e}});let r=await c();return d(r),r},unenrollTotp:async()=>{await l.fetchPrivyRoute(i.MfaAuthTotpUnenroll,{body:{}});let e=await c();return d(e),e},enrollPasskey:async e=>{await l.fetchPrivyRoute(i.MfaAuthPasskeyEnrollment,{body:{credential_ids:e,remove_for_login:!0}});let r=await c();return d(r),r}}}),o(m)}))})),[l,a,o,u])},exports.useAuthorizationSignature=()=>{let{signWithUserSigner:e}=a.useSignWithUserSigner();return r.useMemo((()=>({async generateAuthorizationSignature(r){let{signature:t}=await y.generateAuthorizationSignature(e,r);return{signature:t}}})),[e])},exports.useBaseAccountSdk=()=>{let{baseAccountSdk:e}=s.usePrivyInternal();return{baseAccountSdk:e}},exports.useConnectBaseAccount=()=>{let{connectBaseAccount:e}=s.usePrivyInternal();return{connectBaseAccount:e}},exports.useConnectCoinbaseSmartWallet=()=>{let{connectCoinbaseSmartWallet:e}=s.usePrivyInternal();return{connectCoinbaseSmartWallet:e}},exports.useConnectOrCreateWallet=r=>{let{connectOrCreateWallet:t}=a.usePrivyContext();return e.usePrivyEventSubscription("connectOrCreateWallet",r),{connectOrCreateWallet:t}},exports.useCrossAppAccounts=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:r,signMessageWithCrossAppWallet:t,signTypedDataWithCrossAppWallet:s,sendTransactionWithCrossAppWallet:n,signTransactionWithCrossAppWallet:o}=a.usePrivyContext();return{loginWithCrossAppAccount:({appId:r})=>e({appId:r,action:"login"}),linkCrossAppAccount:({appId:r})=>e({appId:r,action:"link"}),unlinkCrossAppAccount:r,signMessage:t,signTypedData:s,sendTransaction:n,signTransaction:o}},exports.useCustomAuth=r=>{let t=e.useJwtAuthFlowState();return e.usePrivyEventSubscription("customAuth",r),{status:t}},exports.useDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=s.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},exports.useFarcasterSigner=function(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:t}=a.usePrivyContext();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:t}},exports.useGuestAccounts=function(){let r=e.useAppConfig(),a=e.useEmitPrivyEvent(),{client:n,setUser:o,setAuthenticated:i,setIsNewUser:l,initializeWalletProxy:u}=s.usePrivyInternal(),{create:c}=e.useCreateWalletInternal();return{createGuestAccount:async()=>{if(!r.id||!n)throw Error("SDK not yet ready");n.startAuthFlow(new e.GuestFlow(r.id));try{let s=await n.authenticate(),d=s.user,h=s.isNewUser??!1;if(!d)throw new t.PrivyClientError("Unable to authenticate guest account");let y=await n.getAccessToken(),p=await u(e.WALLET_PROXY_TIMEOUT);if(y&&p)try{let t=e.shouldCreateEmbeddedEthWallet(d,r.embeddedWallets.ethereum.createOnLogin),s=e.shouldCreateEmbeddedSolWallet(d,r.embeddedWallets.solana.createOnLogin);t&&s?(d=(await c({chainType:"ethereum",latestUser:d})).user,d=(await c({chainType:"solana",latestUser:d})).user):s?d=(await c({chainType:"solana",latestUser:d})).user:t?d=(await c({chainType:"ethereum",latestUser:d})).user:o(d)}catch(e){o(d),console.warn("Unable to create embedded wallet for guest account")}return l(h),i(!0),a("login","onComplete",{user:d,isNewUser:h,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),d}catch(e){throw a("login","onError",e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}}},exports.useHeadlessDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=s.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},exports.useLinkAccount=function(t){let{linkEmail:s,linkPhone:n,linkWallet:o,linkGoogle:i,linkApple:l,linkTwitter:u,linkDiscord:c,linkGithub:d,linkLinkedIn:h,linkTiktok:y,linkLine:p,linkSpotify:w,linkInstagram:g,linkTelegram:C,linkFarcaster:v,linkPasskey:A}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("linkAccount",t),{linkEmail:s,linkPhone:n,linkWallet:o,linkGoogle:i,linkApple:l,linkTwitter:u,linkDiscord:c,linkGithub:d,linkLinkedIn:h,linkTiktok:y,linkLine:p,linkSpotify:w,linkInstagram:g,linkFarcaster:v,linkTelegram:C,linkPasskey:A}},exports.useLinkJwtAccount=function(a){let{client:n}=s.usePrivyInternal(),[o,i]=r.useState({status:"initial"});return{linkWithCustomJwt:r.useCallback((async r=>{try{i({status:"initial"}),n.startAuthFlow(new e.CustomJwtAccountFlow(r)),i({status:"loading"});let{user:t}=await n.link();if(!t)throw Error("Error, user not found");let s=t.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,r)=>r.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return i({status:"done"}),a?.onSuccess?.({user:t,linkMethod:"custom",linkedAccount:s}),{user:t}}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),r}}),[n.startAuthFlow,n.link]),state:o}},exports.useLinkWithPasskey=e=>{let{initLinkWithPasskey:a,linkWithPasskey:n,passkeyAuthState:o,setPasskeyAuthState:i}=s.usePrivyInternal();return{linkWithPasskey:r.useCallback((async()=>{try{await a();let r=await n();if(!r)throw Error("Error, user not found");let t=r.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,r)=>r.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:"passkey",linkedAccount:t})}catch(r){throw i({status:"error",error:r}),e?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),r}}),[n]),state:o}},exports.useLinkWithSiwe=a=>{let n=e.useCaptcha(),{siweState:o,setSiweState:i,linkWithSiwe:l,generateSiweMessage:u}=s.usePrivyInternal();return{generateSiweMessage:r.useCallback((async({address:e,chainId:r})=>{try{if(!e||!r)throw Error("wallet address and chainId required to generate nonce");return await u({address:e,chainId:r}).then((e=>e))}catch(e){throw i({status:"error",error:e}),a?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),e}}),[u]),linkWithSiwe:r.useCallback((async({signature:r,message:s,chainId:o,walletClientType:u,connectorType:c})=>{try{if(n.enabled&&"success"!==n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:i,linkedAccount:d}=await l({message:s,signature:r,chainId:o,walletClientType:u,connectorType:c});d&&a?.onSuccess?.({user:i,linkMethod:"siwe",linkedAccount:d})}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[l,n.status]),state:o}},exports.useLinkWithSiws=()=>{let a=e.useCaptcha(),{client:n,setUser:o,refreshSessionAndUser:i}=s.usePrivyInternal(),{authenticated:l}=e.usePrivy();return{generateSiwsMessage:r.useCallback((async({address:r})=>{let s;if(a.enabled&&"error"===a.status)throw new e.CaptchaError(a.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);a.enabled&&"success"!==a.status&&(a.execute(),s=await a.waitForResult());let o=await n.generateSiwsNonce({address:r,captchaToken:s});return e.prepareSiwsMessageWithNonce({address:r,nonce:o})}),[a,n]),linkWithSiws:r.useCallback((async({signature:r,message:s,walletClientType:u,connectorType:c})=>{if(!l)throw Error("User must be authenticated before linking");if(a.enabled&&"error"===a.status)throw new e.CaptchaError(a.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let d=await n.linkWithSiws({message:s,signature:r,walletClientType:u,connectorType:c,messageType:"plain"}),h=(e=>{if(!e)return;let r=e.linkedAccounts;return r&&0!==r.length?r[r.length-1]:void 0})(d=await i()??d)||null;return o(d||null),{user:d,linkedAccount:h}}),[l,a,n,i,o])}},exports.useLoginWithEmail=a=>{let n=e.useCaptcha(),{emailOtpState:o,setEmailOtpState:i,initLoginWithEmail:l,loginWithCode:u}=s.usePrivyInternal();return{sendCode:r.useCallback((async({email:r,disableSignup:s})=>{try{let a;if(!r)throw Error("Email required to send OTP code");if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return n.enabled&&"success"!==n.status&&(n.execute(),a=await n.waitForResult()),await l({email:r,captchaToken:a,disableSignup:s,withPrivyUi:!1})}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l]),loginWithCode:r.useCallback((async({code:r})=>{try{if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:s,isNewUser:o,wasAlreadyAuthenticated:i,linkedAccount:l}=await u(r);a?.onComplete?.({user:s,isNewUser:o,wasAlreadyAuthenticated:i,loginMethod:"email",loginAccount:l})}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,n.status]),state:o}},exports.useLoginWithFarcasterV2=()=>{let{client:e,setAuthenticated:a,setUser:n}=s.usePrivyInternal();return r.useMemo((()=>({init:async()=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");let r=new o.FarcasterFramesFlow;return e.startAuthFlow(r),await r.init()},login:async({fid:r,message:s,signature:i})=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");if(!(e.authFlow instanceof o.FarcasterFramesFlow))throw new t.PrivyClientError("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:s,signature:i,fid:r});let{user:l}=await e.authenticate();if(!l)throw new t.PrivyClientError("Failed to login with Farcaster V2");return n(l),a(!0),{user:l}}})),[e,n,a])},exports.useLoginWithOAuth=n=>{e.usePrivyEventSubscription("login",n);let o=e.useCaptcha(),i=e.useIsServerConfigLoaded(),{ready:l,user:u}=a.usePrivyContext(),{initLoginWithHeadlessOAuth:c,loginWithHeadlessOAuth:d,oAuthState:h,setOAuthState:y,isHeadlessOAuthLoading:p}=s.usePrivyInternal(),w=r.useCallback((async r=>{try{if(o.enabled&&"success"!==o.status)throw new e.CaptchaError(o.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return await c(r.provider,o.token,r.disableSignup)}catch(r){throw y({status:"error",error:r}),r}}),[c,o]),g=r.useCallback((async()=>{let r=e.detectCompletingOAuthFlow();try{if(u)return console.warn("Cannot login with OAuth when already logged in"),u;if(!r.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(r.popupFlow)return}catch(r){throw y({status:"error",error:r}),r}try{return await d(r)}catch(r){throw y({status:"error",error:r}),r}finally{e.stripUrlOAuthParamsAndRemoveStateCode()}}),[d]);return r.useEffect((()=>{let r=e.detectCompletingOAuthFlow();l&&i&&r.inProgress&&!r.withPrivyUi&&!r.popupFlow&&g().catch((()=>{}))}),[l,i]),{initOAuth:w,loading:p,state:h}},exports.useLoginWithPasskey=a=>{let n=e.useCaptcha(),{initLoginWithPasskey:o,loginWithPasskey:i,passkeyAuthState:l,setPasskeyAuthState:u}=s.usePrivyInternal();return{loginWithPasskey:r.useCallback((async r=>{try{let s;if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);n.enabled&&"success"!==n.status&&(n.execute(),s=await n.waitForResult()),await o({captchaToken:s,withPrivyUi:!1});let{user:l,isNewUser:u,wasAlreadyAuthenticated:c,loginAccount:d}=await i(r);a?.onComplete?.({user:l,isNewUser:u,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:d})}catch(r){throw u({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[i,n.status]),state:l}},exports.useLoginWithSiwe=a=>{let n=e.useCaptcha(),{siweState:o,setSiweState:i,client:l,generateSiweMessage:u,loginWithSiwe:c}=s.usePrivyInternal();return{generateSiweNonce:r.useCallback((async r=>{try{let s;if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);n.enabled&&"success"!==n.status&&(n.execute(),s=await n.waitForResult()),i({status:"generating-message"});let a=await l.generateSiweNonce({address:r?.address,captchaToken:s});return i({status:"awaiting-signature"}),a}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l,n]),generateSiweMessage:r.useCallback((async({address:r,chainId:s})=>{try{let a;if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return n.enabled&&"success"!==n.status&&(n.execute(),a=await n.waitForResult()),await u({address:r,chainId:s,captchaToken:a})}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,n]),loginWithSiwe:r.useCallback((async({message:r,signature:s,disableSignup:o})=>{try{let i;if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);n.enabled&&"success"!==n.status&&(n.execute(),i=await n.waitForResult());let l=await c({message:r,signature:s,captchaToken:i,disableSignup:o});return a?.onComplete?.({user:l,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),l}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[c,n.status]),state:o}},exports.useLoginWithSiws=()=>{let a=e.useCaptcha(),{client:n,setAuthenticated:o,setUser:i,setIsNewUser:l}=s.usePrivyInternal(),{authenticated:u}=e.usePrivy();return{generateSiwsMessage:r.useCallback((async({address:r})=>{let s;if(a.enabled&&"error"===a.status)throw new e.CaptchaError(a.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);a.enabled&&"success"!==a.status&&(a.execute(),s=await a.waitForResult());let o=await n.generateSiwsNonce({address:r,captchaToken:s});return e.prepareSiwsMessageWithNonce({address:r,nonce:o})}),[a,n]),loginWithSiws:r.useCallback((async({message:r,signature:s,disableSignup:c})=>{if(u)throw Error("User already authenticated");if(a.enabled&&"error"===a.status)throw new e.CaptchaError(a.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);a.enabled&&"success"!==a.status&&(a.execute(),await a.waitForResult());let{user:d,isNewUser:h}=await n.authenticateWithSiws({message:r,signature:s,mode:c?"no-signup":"login-or-sign-up",messageType:"plain"});if(!d)throw Error("Authentication failed - no user returned");return i(d),l(h||!1),o(!0),d}),[u,a,n,o,i,l])}},exports.useLoginWithSms=a=>{let n=e.useCaptcha(),{smsOtpState:o,setSmsOtpState:i,initLoginWithSms:l,loginWithCode:u}=s.usePrivyInternal();return{sendCode:r.useCallback((async({phoneNumber:r,disableSignup:s})=>{try{let a;if(!r)throw Error("SMS required to send OTP code");if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return n.enabled&&"success"!==n.status&&(n.execute(),a=await n.waitForResult()),await l({phoneNumber:r,captchaToken:a,disableSignup:s,withPrivyUi:!1})}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l]),loginWithCode:r.useCallback((async({code:r})=>{try{if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:s,isNewUser:o,wasAlreadyAuthenticated:i,linkedAccount:l}=await u(r);a?.onComplete?.({user:s,isNewUser:o,wasAlreadyAuthenticated:i,loginMethod:"sms",loginAccount:l})}catch(r){throw i({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,n.status]),state:o}},exports.useLoginWithTelegram=a=>{let n=e.useCaptcha(),{initLoginWithTelegram:o,loginWithTelegram:i,telegramAuthState:l,setTelegramAuthState:u}=s.usePrivyInternal();return{login:r.useCallback((async r=>{try{if(n.enabled&&"success"!==n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);await o(n.token,r?.disableSignup);let{user:s,isNewUser:l,loginAccount:u,wasAlreadyAuthenticated:c}=await i({intent:"login"});a?.onComplete?.({user:s,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:u})}catch(r){throw u({status:"error",error:r}),a?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[o,i,n]),state:l}},exports.useModalStatus=()=>{let{isModalOpen:e}=r.useContext(a.PrivyContext);return{isOpen:e}},exports.useOAuthTokens=function(r){let{authenticated:t,user:n}=a.usePrivyContext(),{initLoginWithOAuth:o}=s.usePrivyInternal(),i=e.useEmitPrivyEvent();return e.usePrivyEventSubscription("oAuthAuthorization",r),{reauthorize:e=>E(t,n,o,i,e.provider)}},exports.useRecoverEmbeddedWallet=()=>{let{user:n}=a.usePrivyContext(),{walletProxy:o}=s.usePrivyInternal();return{recover:r.useCallback((async r=>{if(!o)throw Error("Wallet proxy is not ready");let s=await e.getAccessToken();if(!n||!s)throw new t.PrivyClientError("User must be logged in before attempting to modify the recovery method.");let{entropyId:a,entropyIdVerifier:i}=e.getEntropyDetailsForUser(n);try{await o.recover({entropyId:a,entropyIdVerifier:i,accessToken:s,...r})}catch{throw new t.PrivyClientError("Unable to recover wallets")}}),[o,n])}},exports.useSendTransaction=function(t){let{sendTransaction:s}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("sendTransaction",t),{sendTransaction:s}},exports.useSessionSigners=()=>{let{addSessionSignersInternal:r,removeSessionSignersInternal:n}=(()=>{let{user:r}=a.usePrivyContext(),n=s.usePrivyInternal(),{signWithUserSigner:o}=a.useSignWithUserSigner(),i=async({wallet:e,additional_signers:s})=>{let a=await n.client.getAccessToken();if(!r||!a)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!e.id)throw new t.PrivyClientError("Wallet to add signers to must have ID on server");if(!n.walletProxy)throw new t.PrivyClientError("Wallet proxy not initialized.");await y.updateWallet(n.privy,{wallet_id:e.id},o,{additional_signers:s})};return{addSessionSignersInternal:async({address:s,signers:o})=>{let l=await n.client.getAccessToken();if(!r||!l)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to add a session signer.");let u=n.walletProxy??await n.initializeWalletProxy(15e3);if(!u)throw new t.PrivyClientError("Wallet proxy not initialized.");let c=a.getPrivyWalletWithAddress(r,s);if(!c)throw new t.PrivyClientError("Address to add signers too is not associated with current user.");if(a.getIsUnifiedWallet(c)){if(0===o.length)throw new t.PrivyClientError("Must specify at least one signer to add.");let r=[...(await y.getWallet(n.privy,{wallet_id:c.id})).additional_signers,...e.parseAdditionalSigners(o)];await i({wallet:c,additional_signers:r})}else{if(c.delegated)return{user:r};if(o.length>0)throw new t.PrivyClientError("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let a=e.getDelegatedWalletsData({address:s,user:r}),i=e.getRootWalletDataForDelegation({address:s,user:r});await n.recoverEmbeddedWallet({address:s}),await u.createDelegatedAction({accessToken:l,rootWallet:i,delegatedWallets:[a]})}let d=await n.refreshSessionAndUser();if(!d)throw Error("Could not refresh user");return{user:d}},removeSessionSignersInternal:async({address:e})=>{let s=await n.client.getAccessToken();if(!r||!s)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!(n.walletProxy??await n.initializeWalletProxy(15e3)))throw new t.PrivyClientError("Wallet proxy not initialized.");let o=a.getPrivyWalletWithAddress(r,e);if(!o)throw new t.PrivyClientError("Address to remove signers from is not associated with current user.");a.getIsUnifiedWallet(o)?await i({wallet:o,additional_signers:[]}):await n.client.revokeDelegatedWallet();let l=await n.refreshSessionAndUser();if(!l)throw Error("Could not refresh user");return{user:l}}}})();return{addSessionSigners:async({address:e,signers:t})=>r({address:e,signers:t}),removeSessionSigners:async({address:e})=>n({address:e})}},exports.useSetWalletPassword=function(t){let{setWalletPassword:s}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("setWalletPassword",t),{setWalletPassword:s}},exports.useSetWalletRecovery=function(t){let{setWalletRecovery:s}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("setWalletRecovery",t),{setWalletRecovery:s}},exports.useSign7702Authorization=f,exports.useSignAuthorization=P,exports.useSignMessage=function(t){let{signMessage:s}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("signMessage",t),{signMessage:s}},exports.useSignTransaction=function(){let{signTransaction:e}=r.useContext(a.PrivyContext);return{signTransaction:e}},exports.useSignTypedData=function(t){let{signTypedData:s}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("signTypedData",t),{signTypedData:s}},exports.useSignupWithPasskey=a=>{let n=e.useCaptcha(),{initSignupWithPasskey:o,signupWithPasskey:i,passkeyAuthState:l,setPasskeyAuthState:u}=s.usePrivyInternal();return{signupWithPasskey:r.useCallback((async()=>{try{let r;if(n.enabled&&"error"===n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);n.enabled&&"success"!==n.status&&(n.execute(),r=await n.waitForResult()),await o({captchaToken:r,withPrivyUi:!1});let{user:s,isNewUser:l,wasAlreadyAuthenticated:u,loginAccount:c}=await i();a?.onComplete?.({user:s,isNewUser:l,wasAlreadyAuthenticated:u,loginMethod:"passkey",loginAccount:c})}catch(e){throw u({status:"error",error:e}),a?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}),[i,n.status]),state:l}},exports.useSubscribeToJwtAuthWithFlag=function({isAuthenticated:t,isLoading:s,...a}){let n=r.useRef();r.useEffect((()=>{s||n.current?.()}),[t,s]);let o=r.useCallback((e=>(n.current=e,()=>{n.current=void 0})),[]);return e.useSyncJwtBasedAuthState({...a,subscribe:o})},exports.useToken=function(t){let{getAccessToken:s}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("accessToken",t),{getAccessToken:s}},exports.useUpdateAccount=function(t){let{updateEmail:s,updatePhone:n}=r.useContext(a.PrivyContext);return e.usePrivyEventSubscription("update",t),{updateEmail:s,updatePhone:n}},exports.useUpdateEmail=n=>{let{user:o}=a.usePrivyContext(),{loginWithCode:i,emailOtpState:l,setEmailOtpState:u,client:c,inProgressAuthFlowRef:d,inProgressLoginOrLinkMethodRef:h}=s.usePrivyInternal();return{state:l,sendCode:r.useCallback((async({newEmailAddress:r})=>{try{if(!o?.email)throw Error("User is required to have an email address to update it.");let t=new e.UpdateEmailFlow(o.email.address,r);c.startAuthFlow(t),await t.sendCodeEmail({withPrivyUi:!1})}catch(r){u({status:"error",error:r}),n?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[o?.email]),verifyCode:r.useCallback((async({code:e})=>{try{if(!o?.email)throw Error("User is required to have an email address to update it.");d.current="update",h.current="email";let{user:r,linkedAccount:t}=await i(e);return n?.onSuccess?.({user:r,updateMethod:"email",updatedAccount:t}),{user:r}}catch(e){u({status:"error",error:e}),n?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[o?.email])}},exports.useUser=()=>{let{setUser:e,client:t}=r.useContext(s.InternalPrivyContext),{user:n}=r.useContext(a.PrivyContext);return{user:n,refreshUser:r.useCallback((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}};
