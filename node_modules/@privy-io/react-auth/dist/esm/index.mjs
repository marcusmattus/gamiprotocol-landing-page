import{g as e,a as t,u as r,b as s,c as n,C as o,d as i,s as l,e as d,p as h,U as w,f as p,h as m,t as y,i as f,M as A,j as k,A as C,k as v,l as E,L as T,m as S,I as U,T as W,S as I,B as P,P as M,E as N,n as F,o as L,q as H,r as x,v as D,G as K,W as q,w as z,x as j,y as B,z as G,D as J,F as ee,H as te,J as re,K as ae,N as se}from"./privy-provider-C-OGn-Rn.mjs";export{R as Captcha,V as ConnectorManager,Y as EthereumWalletConnector,aa as LoginModal,a3 as PrivyClient,O as PrivyProvider,a2 as VERSION,X as WalletConnector,a0 as errorIndicatesMaxMfaRetries,a1 as errorIndicatesMfaTimeout,$ as errorIndicatesMfaVerificationFailed,Q as getAccessToken,a7 as useCreateWallet,a4 as useIdentityToken,a9 as useImportWallet,a5 as useLogout,Z as useMfa,_ as useMfaEnrollment,ab as useMigrateWallets,a6 as useRegisterMfaListener,a8 as useSolanaWallets}from"./privy-provider-C-OGn-Rn.mjs";import{useCallback as ne,useMemo as oe,useEffect as ie,useContext as le,useState as ce,useRef as ue}from"react";import{P as de,a as he}from"./paths-DCwuPDUk.mjs";import{u as we,I as pe}from"./internal-context-qdNgTV5f.mjs";import{u as me,P as ye,g as ge,a as fe,b as Ae,c as ke}from"./use-sign-with-user-signer-CpL9I6iB.mjs";export{c as useActiveWallet,a as useConnectWallet,b as useFundWallet,u as useLogin}from"./useActiveWallet-Bj6Y6Ioo.mjs";import{F as Ce}from"./frame-DMd4vZ0H.mjs";import{MfaAuthTotpVerify as ve,MfaAuthPasskeyInit as Ee,MfaAuthPasskeyVerify as Te,MfaAuthTotpInit as Se,MfaAuthTotpEnroll as Ue,MfaAuthTotpUnenroll as We,MfaAuthPasskeyEnrollment as Ie}from"@privy-io/public-api";import{jsxs as Re,Fragment as be,jsx as Pe}from"react/jsx-runtime";import Me from"@heroicons/react/24/outline/QuestionMarkCircleIcon";import Ne from"@heroicons/react/24/outline/ShieldCheckIcon";import{zeroAddress as _e,getAddress as Oe,createWalletClient as Fe,http as Le,parseSignature as He}from"viem";import{hashAuthorization as xe}from"viem/utils";import{getWallet as De,updateWallet as Ke,generateAuthorizationSignature as qe,PrivyClientError as ze}from"@privy-io/js-sdk-core";export{DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS,addPrivyRpcToChain,addRpcUrlOverrideToChain}from"@privy-io/js-sdk-core";export{g as getEmbeddedConnectedWallet}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import{toAccount as je}from"viem/accounts";import"mipd";import"react-device-detect";import"uuid";import"jose";import"eventemitter3";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"@marsidev/react-turnstile";import"styled-components";import"tinycolor2";import"@heroicons/react/24/outline/DevicePhoneMobileIcon";import"@heroicons/react/24/outline/FingerPrintIcon";import"@heroicons/react/24/outline/PhoneIcon";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/XMarkIcon";import"@heroicons/react/24/outline/CalendarIcon";import"@heroicons/react/24/outline/ExclamationTriangleIcon";import"@heroicons/react/24/outline/ChevronDownIcon";import"zustand";import"@headlessui/react";import"lucide-react";import"@walletconnect/ethereum-provider";import"fast-password-entropy";import"secure-password-utilities";import"secure-password-utilities/wordlists";import"@heroicons/react/24/outline/UserCircleIcon";import"@heroicons/react/20/solid/CheckIcon";import"@heroicons/react/24/outline/EnvelopeIcon";import"@heroicons/react/24/outline/WalletIcon";import"@heroicons/react/24/outline/ExclamationCircleIcon";import"@heroicons/react/24/outline/Square2StackIcon";import"@heroicons/react/24/outline";import"@tanstack/react-virtual";import"@heroicons/react/24/outline/CheckIcon";import"qrcode";import"@heroicons/react/24/outline/LockClosedIcon";import"@heroicons/react/24/outline/PencilSquareIcon";import"@heroicons/react/24/outline/ArrowPathIcon";import"@heroicons/react/24/outline/EyeIcon";import"@heroicons/react/24/outline/EyeSlashIcon";import"@heroicons/react/24/outline/KeyIcon";import"@heroicons/react/24/solid/CheckCircleIcon";import"@heroicons/react/24/outline/ArrowDownTrayIcon";import"@heroicons/react/24/outline/ClipboardDocumentCheckIcon";import"@heroicons/react/24/outline/DocumentDuplicateIcon";import"@heroicons/react/24/solid/XCircleIcon";import"@heroicons/react/24/outline/CheckCircleIcon";import"@heroicons/react/24/outline/InformationCircleIcon";import"@heroicons/react/24/outline/CreditCardIcon";import"@heroicons/react/24/outline/QrCodeIcon";import"@heroicons/react/24/solid/ArrowsRightLeftIcon";import"@heroicons/react/24/outline/GlobeAltIcon";import"ofetch";import"@heroicons/react/24/outline/ClipboardDocumentIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/IdentificationIcon";import"@heroicons/react/24/outline/ChevronRightIcon";import"@heroicons/react/24/outline/MinusCircleIcon";import"@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/solid/ShieldCheckIcon";import"js-cookie";const Ve=()=>{let{user:r}=me(),{walletProxy:a}=we();return{recover:ne((async s=>{if(!a)throw Error("Wallet proxy is not ready");let n=await e();if(!r||!n)throw new de("User must be logged in before attempting to modify the recovery method.");let{entropyId:o,entropyIdVerifier:i}=t(r);try{await a.recover({entropyId:o,entropyIdVerifier:i,accessToken:n,...s})}catch{throw new de("Unable to recover wallets")}}),[a,r])}},Be=()=>{let{client:e,setAuthenticated:t,setUser:r}=we();return oe((()=>({init:async()=>{if(!e)throw new de("Must initialize Privy client first.");let t=new Ce;return e.startAuthFlow(t),await t.init()},login:async({fid:a,message:s,signature:n})=>{if(!e)throw new de("Must initialize Privy client first.");if(!(e.authFlow instanceof Ce))throw new de("Must initialize Farcaster Mini App flow first.");e.authFlow.setAuthData({message:s,signature:n,fid:a});let{user:o}=await e.authenticate();if(!o)throw new de("Failed to login with Farcaster V2");return r(o),t(!0),{user:o}}})),[e,r,t])},Ge=e=>{r("login",e);let t=s(),a=n(),{ready:c,user:u}=me(),{initLoginWithHeadlessOAuth:d,loginWithHeadlessOAuth:h,oAuthState:w,setOAuthState:p,isHeadlessOAuthLoading:m}=we(),y=ne((async e=>{try{if(t.enabled&&"success"!==t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);return await d(e.provider,t.token,e.disableSignup)}catch(e){throw p({status:"error",error:e}),e}}),[d,t]),g=ne((async()=>{let e=i();try{if(u)return console.warn("Cannot login with OAuth when already logged in"),u;if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(e.popupFlow)return}catch(e){throw p({status:"error",error:e}),e}try{return await h(e)}catch(e){throw p({status:"error",error:e}),e}finally{l()}}),[h]);return ie((()=>{let e=i();c&&a&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&g().catch((()=>{}))}),[c,a]),{initOAuth:y,loading:m,state:w}},$e=e=>{let t=s(),{emailOtpState:r,setEmailOtpState:a,initLoginWithEmail:n,loginWithCode:i}=we();return{sendCode:ne((async({email:r,disableSignup:s})=>{try{let e;if(!r)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await n({email:r,captchaToken:e,disableSignup:s,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[n]),loginWithCode:ne((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);let{user:a,isNewUser:s,wasAlreadyAuthenticated:n,linkedAccount:l}=await i(r);e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:n,loginMethod:"email",loginAccount:l})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[i,t.status]),state:r}},Qe=e=>{let t=s(),{initSignupWithPasskey:r,signupWithPasskey:a,passkeyAuthState:n,setPasskeyAuthState:i}=we();return{signupWithPasskey:ne((async()=>{try{let s;if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),s=await t.waitForResult()),await r({captchaToken:s,withPrivyUi:!1});let{user:n,isNewUser:i,wasAlreadyAuthenticated:l,loginAccount:c}=await a();e?.onComplete?.({user:n,isNewUser:i,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||he.UNKNOWN_AUTH_ERROR),t}}),[a,t.status]),state:n}},Xe=e=>{let t=s(),{initLoginWithPasskey:r,loginWithPasskey:a,passkeyAuthState:n,setPasskeyAuthState:i}=we();return{loginWithPasskey:ne((async s=>{try{let n;if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),n=await t.waitForResult()),await r({captchaToken:n,withPrivyUi:!1});let{user:i,isNewUser:l,wasAlreadyAuthenticated:c,loginAccount:u}=await a(s);e?.onComplete?.({user:i,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:u})}catch(s){throw i({status:"error",error:s}),e?.onError?.(s.privyErrorCode||he.UNKNOWN_AUTH_ERROR),s}}),[a,t.status]),state:n}},Je=e=>{let{initLinkWithPasskey:t,linkWithPasskey:r,passkeyAuthState:a,setPasskeyAuthState:s}=we();return{linkWithPasskey:ne((async()=>{try{await t();let a=await r();if(!a)throw Error("Error, user not found");let s=a.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:a,linkMethod:"passkey",linkedAccount:s})}catch(t){throw s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[r]),state:a}},Ye=e=>{let t=s(),{smsOtpState:r,setSmsOtpState:a,initLoginWithSms:n,loginWithCode:i}=we();return{sendCode:ne((async({phoneNumber:r,disableSignup:s})=>{try{let e;if(!r)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await n({phoneNumber:r,captchaToken:e,disableSignup:s,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[n]),loginWithCode:ne((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);let{user:a,isNewUser:s,wasAlreadyAuthenticated:n,linkedAccount:l}=await i(r);e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:n,loginMethod:"sms",loginAccount:l})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[i,t.status]),state:r}},Ze=e=>{let{connectOrCreateWallet:t}=me();return r("connectOrCreateWallet",e),{connectOrCreateWallet:t}},et=e=>{let t=s(),{siweState:r,setSiweState:a,linkWithSiwe:n,generateSiweMessage:i}=we();return{generateSiweMessage:ne((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await i({address:t,chainId:r}).then((e=>e))}catch(t){throw a({status:"error",error:t}),e?.onError?.(t.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[i]),linkWithSiwe:ne((async({signature:r,message:s,chainId:i,walletClientType:l,connectorType:c})=>{try{if(t.enabled&&"success"!==t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);let{user:a,linkedAccount:u}=await n({message:s,signature:r,chainId:i,walletClientType:l,connectorType:c});u&&e?.onSuccess?.({user:a,linkMethod:"siwe",linkedAccount:u})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[n,t.status]),state:r}},tt=e=>{let t=s(),{siweState:r,setSiweState:a,client:n,generateSiweMessage:i,loginWithSiwe:l}=we();return{generateSiweNonce:ne((async r=>{try{let e;if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),a({status:"generating-message"});let s=await n.generateSiweNonce({address:r?.address,captchaToken:e});return a({status:"awaiting-signature"}),s}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[n,t]),generateSiweMessage:ne((async({address:r,chainId:s})=>{try{let e;if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await i({address:r,chainId:s,captchaToken:e})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[i,t]),loginWithSiwe:ne((async({message:r,signature:s,disableSignup:n})=>{try{let a;if(t.enabled&&"error"===t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),a=await t.waitForResult());let i=await l({message:r,signature:s,captchaToken:a,disableSignup:n});return e?.onComplete?.({user:i,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),i}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR),r}}),[l,t.status]),state:r}},rt=()=>{let e=s(),{client:t,setAuthenticated:r,setUser:a,setIsNewUser:n}=we(),{authenticated:i}=d();return{generateSiwsMessage:ne((async({address:r})=>{let a;if(e.enabled&&"error"===e.status)throw new o(e.error,null,he.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),a=await e.waitForResult());let s=await t.generateSiwsNonce({address:r,captchaToken:a});return h({address:r,nonce:s})}),[e,t]),loginWithSiws:ne((async({message:s,signature:l,disableSignup:c})=>{if(i)throw Error("User already authenticated");if(e.enabled&&"error"===e.status)throw new o(e.error,null,he.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),await e.waitForResult());let{user:u,isNewUser:d}=await t.authenticateWithSiws({message:s,signature:l,mode:c?"no-signup":"login-or-sign-up",messageType:"plain"});if(!u)throw Error("Authentication failed - no user returned");return a(u),n(d||!1),r(!0),u}),[i,e,t,r,a,n])}},at=()=>{let e=s(),{client:t,setUser:r,refreshSessionAndUser:a}=we(),{authenticated:n}=d();return{generateSiwsMessage:ne((async({address:r})=>{let a;if(e.enabled&&"error"===e.status)throw new o(e.error,null,he.CAPTCHA_FAILURE);e.enabled&&"success"!==e.status&&(e.execute(),a=await e.waitForResult());let s=await t.generateSiwsNonce({address:r,captchaToken:a});return h({address:r,nonce:s})}),[e,t]),linkWithSiws:ne((async({signature:s,message:i,walletClientType:l,connectorType:c})=>{if(!n)throw Error("User must be authenticated before linking");if(e.enabled&&"error"===e.status)throw new o(e.error,null,he.CAPTCHA_FAILURE);let u=await t.linkWithSiws({message:i,signature:s,walletClientType:l,connectorType:c,messageType:"plain"}),d=(e=>{if(!e)return;let t=e.linkedAccounts;return t&&0!==t.length?t[t.length-1]:void 0})(u=await a()??u)||null;return r(u||null),{user:u,linkedAccount:d}}),[n,e,t,a,r])}};function st(){let{signTransaction:e}=le(ye);return{signTransaction:e}}function nt(e){let{linkEmail:t,linkPhone:a,linkWallet:s,linkGoogle:n,linkApple:o,linkTwitter:i,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkTelegram:m,linkFarcaster:y,linkPasskey:g}=le(ye);return r("linkAccount",e),{linkEmail:t,linkPhone:a,linkWallet:s,linkGoogle:n,linkApple:o,linkTwitter:i,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkFarcaster:y,linkTelegram:m,linkPasskey:g}}function ot(e){let{updateEmail:t,updatePhone:a}=le(ye);return r("update",e),{updateEmail:t,updatePhone:a}}const it=e=>{let{user:t}=me(),{loginWithCode:r,emailOtpState:a,setEmailOtpState:s,client:n,inProgressAuthFlowRef:o,inProgressLoginOrLinkMethodRef:i}=we();return{state:a,sendCode:ne((async({newEmailAddress:r})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");let e=new w(t.email.address,r);n.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(r){s({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email]),verifyCode:ne((async({code:a})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");o.current="update",i.current="email";let{user:s,linkedAccount:n}=await r(a);return e?.onSuccess?.({user:s,updateMethod:"email",updatedAccount:n}),{user:s}}catch(a){s({status:"error",error:a}),e?.onError?.(a.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email])}},lt=()=>{let{connectCoinbaseSmartWallet:e}=we();return{connectCoinbaseSmartWallet:e}},ct=()=>{let{connectBaseAccount:e}=we();return{connectBaseAccount:e}},ut=()=>{let{baseAccountSdk:e}=we();return{baseAccountSdk:e}},dt=()=>{let{setModalData:e}=p(),{openModal:t,privy:r,closePrivyModal:a}=we(),{user:s}=me();return oe((()=>({verify:async({standalone:n=!0}={standalone:!0})=>new Promise(((o,i)=>s?0===s.mfaMethods.length?o():(e((e=>({...e,mfaVerify:{onSuccess:async()=>{n?await a({shouldCallAuthOnSuccess:!1,isSuccess:!0}):m.setState({inProgressMfaFlow:void 0}),o()},onFailure:async e=>{n?await a({shouldCallAuthOnSuccess:!1,isSuccess:!1}):m.setState({inProgressMfaFlow:void 0}),i(e)},sendSmsCode:async()=>{throw Error("Not enabled")},verifySmsCode:async()=>{throw Error("Not enabled")},verifyTotpCode:async e=>{await r.fetchPrivyRoute(ve,{body:{code:e}})},generateOptions:async()=>y((await r.fetchPrivyRoute(Ee,{body:{}})).options),verifyPasskey:async e=>{let t=await import("@simplewebauthn/browser"),a=await t.startAuthentication(e);await r.fetchPrivyRoute(Te,{body:{authenticator_response:f(a)}})}}}))),void(n?t(A):m.setState({inProgressMfaFlow:"auth"}))):i(Error("Must be logged in to verify MFA"))))})),[r,e,t,a])},ht={component:()=>{let{user:e,ready:t}=me(),{app:r,data:a,onUserCloseViaDialogOrKeybindRef:s}=p(),[n,o]=ce(null),[i,l]=ce(null),[c,u]=ce(null),[d,h]=ce(!1),[w,m]=ce(!1),[y,g]=ce(),f=async()=>{y?A(y):e?await R({user:e}):A(Error("Must be logged in to manage MFA")),setTimeout((()=>{o(null),l(null)}),500)};if(s.current=f,!a?.mfaEnroll)throw Error("Missing modal data for MFA enrollment screen.");let{onFailure:A,onSuccess:R,mfaMethods:b,verify:_,generateTotpSecret:O,enrollTotp:H,unenrollTotp:x,enrollPasskey:D}=a.mfaEnroll,K=e?.mfaMethods.includes("sms"),q=e?.mfaMethods.includes("totp"),z=e?.mfaMethods.includes("passkey"),j=!!e?.phone,V=e?.linkedAccounts.filter((e=>"passkey"===e.type)).map((e=>e.credentialId))??[];function B(){o(null),l(null),g(void 0)}async function G(e=V){try{g(void 0),m(!0);let t=await D(e);return await R({user:t})}catch(e){g(e)}finally{m(!1),h(!1)}}if(!t||!e||!r)/*#__PURE__*/return Re(be,{children:[/*#__PURE__*/Pe(k,{onClose:f},"header"),/*#__PURE__*/Pe(C,{children:/*#__PURE__*/Pe(v,{})}),/*#__PURE__*/Pe(E,{children:/*#__PURE__*/Pe(T,{})}),/*#__PURE__*/Pe(S,{})]});if("sms"===n)return null;if("totp"===n)/*#__PURE__*/return Re(be,{children:[/*#__PURE__*/Pe(k,{backFn:B,onClose:f},"header"),/*#__PURE__*/Pe(U,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/Pe(Me,{})}),/*#__PURE__*/Pe(W,{children:"Remove authenticator app verification?"}),/*#__PURE__*/Re(I,{children:["MFA adds an extra layer of security to your ",r?.name," account. Make sure you have other methods to secure your account."]}),/*#__PURE__*/Pe(P,{children:/*#__PURE__*/Pe(M,{$warn:!0,onClick:async function(){try{g(void 0),m(!0);let e=await x();return await R({user:e})}catch(e){g(e)}finally{m(!1),o(null)}},loading:w,children:"Remove"})}),/*#__PURE__*/Pe(S,{})]});if("passkey"===n){let e=a.mfaEnroll.shouldUnlinkOnUnenrollMfa??!0;/*#__PURE__*/return Re(be,{children:[/*#__PURE__*/Pe(k,{backFn:B,onClose:f},"header"),/*#__PURE__*/Pe(U,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/Pe(Me,{})}),/*#__PURE__*/Pe(W,{children:"Are you sure you want to remove this passkey?"}),/*#__PURE__*/Pe(I,{children:e?"Removing your passkey will remove as both a verification method and a login method.":"Removing your passkey will remove as a verification method."}),/*#__PURE__*/Pe(P,{children:/*#__PURE__*/Pe(M,{$warn:!0,onClick:async function(){try{g(void 0),m(!0);let e=await D([]);return await R({user:e})}catch(e){g(e)}finally{m(!1),o(null)}},loading:w,children:"Remove"})}),/*#__PURE__*/Pe(S,{})]})}return 0!==b.length||K||q||z?"sms"===i?null:"totp"===i&&c?/*#__PURE__*/Pe(N,{onClose:f,onReset:B,submitEnrollmentWithTotp:e=>async function(e){try{g(void 0),m(!0);let t=await H(e);return await R({user:t})}catch(e){g(e)}finally{m(!1),o(null)}}(e.mfaCode),error:y,totpInfo:{...c,appName:r?.name||"Privy"}}):"passkey"===i?/*#__PURE__*/Pe(F,{onReset:B,onClose:f,submitEnrollmentWithPasskey:G}):/*#__PURE__*/Pe(L,{showIntro:!1,userMfaMethods:e.mfaMethods,appMfaMethods:r.mfa.methods,userHasAuthSms:j,onBackToIntro:()=>{},handleSelectMethod:async function(e){g(void 0);try{await _()}catch(e){return void g(e)}return"totp"===e?(l(e),u(null),void O().then((({totpSecret:e,totpAuthUrl:t})=>{u({authUrl:t,secret:e})})).catch((()=>{u(null),B()}))):"passkey"===e&&1===V.length?await G():void l(e)},isTotpLoading:"totp"===i&&!c,isPasskeyLoading:d,error:y,onClose:f,setRemovingMfaMethod:async function(e){g(void 0);try{await _()}catch(e){return void g(e)}o(e)}}):/*#__PURE__*/Re(be,{children:[/*#__PURE__*/Pe(k,{onClose:f},"header"),/*#__PURE__*/Pe(U,{style:{marginBottom:"1.5rem"},children:/*#__PURE__*/Pe(Ne,{})}),/*#__PURE__*/Pe(W,{children:"Add more security"}),/*#__PURE__*/Re(I,{children:[r?.name," does not have any verification methods enabled."]}),/*#__PURE__*/Pe(P,{children:/*#__PURE__*/Pe(M,{onClick:f,children:"Close"})}),/*#__PURE__*/Pe(S,{})]})}},wt=()=>{let e=H(),{setModalData:t}=p(),{verify:r}=dt(),{openModal:a,privy:s,closePrivyModal:n,refreshSessionAndUser:o,setUser:i}=we();return oe((()=>({enroll:async()=>new Promise(((l,c)=>{t({mfaEnroll:{onSuccess:async e=>{await n({shouldCallAuthOnSuccess:!1,isSuccess:!0}),l(e)},onFailure:async e=>{await n({shouldCallAuthOnSuccess:!1,isSuccess:!1}),c(e)},verify:()=>r({standalone:!1}),shouldUnlinkOnUnenrollMfa:!0,mfaMethods:e.mfa.methods,sendSmsCode:async()=>{throw Error("Not enabled")},enrollSms:async()=>{throw Error("Not enabled")},unenrollSms:async()=>{throw Error("Not enabled")},generateTotpSecret:async()=>await s.fetchPrivyRoute(Se,{body:{}}),enrollTotp:async e=>{await s.fetchPrivyRoute(Ue,{body:{code:e}});let t=await o();return i(t),t},unenrollTotp:async()=>{await s.fetchPrivyRoute(We,{body:{}});let e=await o();return i(e),e},enrollPasskey:async e=>{await s.fetchPrivyRoute(Ie,{body:{credential_ids:e,remove_for_login:!0}});let t=await o();return i(t),t}}}),a(ht)}))})),[s,t,a,n])},pt=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:r,signTypedDataWithCrossAppWallet:a,sendTransactionWithCrossAppWallet:s,signTransactionWithCrossAppWallet:n}=me();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:r,signTypedData:a,sendTransaction:s,signTransaction:n}};function mt(e){let{sendTransaction:t}=le(ye);return r("sendTransaction",e),{sendTransaction:t}}function yt(e){let{setWalletPassword:t}=le(ye);return r("setWalletPassword",e),{setWalletPassword:t}}function gt(){let e=H(),t=x(),{client:r,setUser:a,setAuthenticated:s,setIsNewUser:n,initializeWalletProxy:o}=we(),{create:i}=D();return{createGuestAccount:async()=>{if(!e.id||!r)throw Error("SDK not yet ready");r.startAuthFlow(new K(e.id));try{let l=await r.authenticate(),c=l.user,u=l.isNewUser??!1;if(!c)throw new de("Unable to authenticate guest account");let d=await r.getAccessToken(),h=await o(q);if(d&&h)try{let t=z(c,e.embeddedWallets.ethereum.createOnLogin),r=j(c,e.embeddedWallets.solana.createOnLogin);t&&r?(c=(await i({chainType:"ethereum",latestUser:c})).user,c=(await i({chainType:"solana",latestUser:c})).user):r?c=(await i({chainType:"solana",latestUser:c})).user:t?c=(await i({chainType:"ethereum",latestUser:c})).user:a(c)}catch(e){a(c),console.warn("Unable to create embedded wallet for guest account")}return n(u),s(!0),t("login","onComplete",{user:c,isNewUser:u,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),c}catch(e){throw t("login","onError",e.privyErrorCode||he.UNKNOWN_AUTH_ERROR),e}}}}function ft(e){let{setWalletRecovery:t}=le(ye);return r("setWalletRecovery",e),{setWalletRecovery:t}}function At(e){let{signMessage:t}=le(ye);return r("signMessage",e),{signMessage:t}}const kt=()=>{let{ready:e,wallets:t}=B(),{user:r}=me(),{rpcConfig:a,chains:s,appId:n}=we();return{signAuthorization:ne((async(o,i)=>{let l;if(!r)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let c=i?.address??ge(r)?.address??_e,u=t.find((e=>Oe(e.address)===Oe(c)));if(!u)throw Error("Signing wallet not found.");let d=o.chainId??Number(u.chainId.split(":")[1]);if(0===d)l={chainId:0,address:o.contractAddress,nonce:o.nonce??0};else{let e=s.find((e=>e.id===d));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let t=Fe({account:c,chain:e,transport:Le(G(e,a,n))});l=await t.prepareAuthorization({...o})}let h=await u.getEthereumProvider(),w=await h.request({method:"secp256k1_sign",params:[xe(l)]});return{...l,...He(w)}}),[e,t,r,s])}},Ct=kt;function vt(e){let{signTypedData:t}=le(ye);return r("signTypedData",e),{signTypedData:t}}const Et=()=>{let{isModalOpen:e}=le(ye);return{isOpen:e}};function Tt(e){let{getAccessToken:t}=le(ye);return r("accessToken",e),{getAccessToken:t}}function St(e){let{authenticated:t,user:a}=me(),{initLoginWithOAuth:s}=we(),n=x();return r("oAuthAuthorization",e),{reauthorize:e=>Ut(t,a,s,n,e.provider)}}let Ut=async(e,t,r,a,s)=>{if(!e)throw a("linkAccount","onError",he.MUST_BE_AUTHENTICATED,{linkMethod:s}),new de("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(s))))throw new de(`OAuth account of type ${s} not linked to the account.`);await r(s)};function Wt(e){let{client:t}=we(),[r,a]=ce({status:"initial"});return{linkWithCustomJwt:ne((async r=>{try{a({status:"initial"}),t.startAuthFlow(new J(r)),a({status:"loading"});let{user:s}=await t.link();if(!s)throw Error("Error, user not found");let n=s.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return a({status:"done"}),e?.onSuccess?.({user:s,linkMethod:"custom",linkedAccount:n}),{user:s}}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||he.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),r}}),[t.startAuthFlow,t.link]),state:r}}const It=e=>{let t=ee();return r("customAuth",e),{status:t}};function Rt({isAuthenticated:e,isLoading:t,...r}){let a=ue();ie((()=>{t||a.current?.()}),[e,t]);let s=ne((e=>(a.current=e,()=>{a.current=void 0})),[]);return te({...r,subscribe:s})}function bt(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}=me();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}}const Pt=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=we();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},Mt=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=(()=>{let{user:e}=me(),t=we(),{signWithUserSigner:r}=fe(),a=async({wallet:a,additional_signers:s})=>{let n=await t.client.getAccessToken();if(!e||!n)throw new de("User must be authenticated and have an embedded wallet to delegate actions.");if(!a.id)throw new de("Wallet to add signers to must have ID on server");if(!t.walletProxy)throw new de("Wallet proxy not initialized.");await Ke(t.privy,{wallet_id:a.id},r,{additional_signers:s})};return{addSessionSignersInternal:async({address:r,signers:s})=>{let n=await t.client.getAccessToken();if(!e||!n)throw new de("User must be authenticated and have an embedded wallet to add a session signer.");let o=t.walletProxy??await t.initializeWalletProxy(15e3);if(!o)throw new de("Wallet proxy not initialized.");let i=Ae(e,r);if(!i)throw new de("Address to add signers too is not associated with current user.");if(ke(i)){if(0===s.length)throw new de("Must specify at least one signer to add.");let e=[...(await De(t.privy,{wallet_id:i.id})).additional_signers,...re(s)];await a({wallet:i,additional_signers:e})}else{if(i.delegated)return{user:e};if(s.length>0)throw new de("Specifying signers in addSessionSigners is only supported for TEE execution and this app uses On-device execution. Pass an empty array for signers instead. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let a=ae({address:r,user:e}),l=se({address:r,user:e});await t.recoverEmbeddedWallet({address:r}),await o.createDelegatedAction({accessToken:n,rootWallet:l,delegatedWallets:[a]})}let l=await t.refreshSessionAndUser();if(!l)throw Error("Could not refresh user");return{user:l}},removeSessionSignersInternal:async({address:r})=>{let s=await t.client.getAccessToken();if(!e||!s)throw new de("User must be authenticated and have an embedded wallet to delegate actions.");if(!(t.walletProxy??await t.initializeWalletProxy(15e3)))throw new de("Wallet proxy not initialized.");let n=Ae(e,r);if(!n)throw new de("Address to remove signers from is not associated with current user.");ke(n)?await a({wallet:n,additional_signers:[]}):await t.client.revokeDelegatedWallet();let o=await t.refreshSessionAndUser();if(!o)throw Error("Could not refresh user");return{user:o}}}})();return{addSessionSigners:async({address:t,signers:r})=>e({address:t,signers:r}),removeSessionSigners:async({address:e})=>t({address:e})}},Nt=()=>{let{signWithUserSigner:e}=fe();return oe((()=>({async generateAuthorizationSignature(t){let{signature:r}=await qe(e,t);return{signature:r}}})),[e])},_t=()=>{let{setUser:e,client:t}=le(pe),{user:r}=le(ye);return{user:r,refreshUser:ne((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}},Ot=e=>{let t=s(),{initLoginWithTelegram:r,loginWithTelegram:a,telegramAuthState:n,setTelegramAuthState:i}=we();return{login:ne((async s=>{try{if(t.enabled&&"success"!==t.status)throw new o(t.error,null,he.CAPTCHA_FAILURE);await r(t.token,s?.disableSignup);let{user:n,isNewUser:i,loginAccount:l,wasAlreadyAuthenticated:c}=await a({intent:"login"});e?.onComplete?.({user:n,isNewUser:i,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:l})}catch(s){throw i({status:"error",error:s}),e?.onError?.(s.privyErrorCode||he.UNKNOWN_AUTH_ERROR),s}}),[r,a,t]),state:n}},Ft=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=we();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},Lt=async({wallet:e})=>{let t=await e.getEthereumProvider();return je({address:e.address,sign:async({hash:r})=>{if("privy"!==e.walletClientType)throw new ze({error:"Unprefixed signing is not supported by external wallets.",code:"unsupported_wallet_type"});return await t.request({method:"secp256k1_sign",params:[r]})},signMessage:async({message:r})=>await t.request({method:"personal_sign",params:[r,e.address]}),signTypedData:async r=>await t.request({method:"eth_signTypedData_v4",params:[e.address,r]}),signTransaction:async e=>await t.request({method:"eth_signTransaction",params:[e]})})};export{Lt as toViemAccount,dt as useAuthMfa,wt as useAuthMfaEnrollment,Nt as useAuthorizationSignature,ut as useBaseAccountSdk,ct as useConnectBaseAccount,lt as useConnectCoinbaseSmartWallet,Ze as useConnectOrCreateWallet,pt as useCrossAppAccounts,It as useCustomAuth,Pt as useDelegatedActions,bt as useFarcasterSigner,gt as useGuestAccounts,Ft as useHeadlessDelegatedActions,nt as useLinkAccount,Wt as useLinkJwtAccount,Je as useLinkWithPasskey,et as useLinkWithSiwe,at as useLinkWithSiws,$e as useLoginWithEmail,Be as useLoginWithFarcasterV2,Ge as useLoginWithOAuth,Xe as useLoginWithPasskey,tt as useLoginWithSiwe,rt as useLoginWithSiws,Ye as useLoginWithSms,Ot as useLoginWithTelegram,Et as useModalStatus,St as useOAuthTokens,d as usePrivy,Ve as useRecoverEmbeddedWallet,mt as useSendTransaction,Mt as useSessionSigners,yt as useSetWalletPassword,ft as useSetWalletRecovery,kt as useSign7702Authorization,Ct as useSignAuthorization,At as useSignMessage,st as useSignTransaction,vt as useSignTypedData,Qe as useSignupWithPasskey,Rt as useSubscribeToJwtAuthWithFlag,te as useSyncJwtBasedAuthState,Tt as useToken,ot as useUpdateAccount,it as useUpdateEmail,_t as useUser,B as useWallets};
